<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Resume | Tristan Yan-Klassen</title>

  <link rel="stylesheet" href="css/style.css" />
  <link rel="stylesheet" href="css/resume.css" />
  <link rel="icon" type="image/png" href="thumb.png" />
</head>

<body class="page-resume">
  <div class="page">
    <header>
      <nav class="top-nav">
        <a class="nav-home" href="index.html">Home</a>
        <a class="nav-about" href="about.html">About</a>
        <a class="active nav-resume" href="resume.html">Resume</a>
        <a class="nav-blog" href="blog.html">Blog</a>
      </nav>
    </header>

    <main>
      <div class="resume-actions">
        <a class="btn" href="resume.pdf" download>Download PDF</a>
        <a class="btn btn-secondary" href="resume.pdf" target="_blank" rel="noopener">Open as PDF</a>
      </div>
      <p class="mobile-resume-note">For smoother mobile viewing, please open or download the PDF.</p>

      <p id="pdf-fallback" style="display:none;">Resume failed to load.</p>
      <div id="pdf-container"></div>
    </main>

    <footer>
      <p class="footer-text">&copy; 2026 Tristan Yan-Klassen</p>
    </footer>
  </div>

  <script type="module">
    import * as pdfjsLib from "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.8.69/build/pdf.mjs";

    const PDF_PATH = "./resume.pdf";
    const MAX_WIDTH = 880;

    // Render quality knob:
    // - Use higher cap for sharper text, but avoid insane canvas sizes on ultra-high-DPR devices.
    const DPR_CAP = 3.0;

    // Manual link overlays in PDF coordinates (points)
    // Add/edit entries here to create clickable areas that scale with the rendered PDF.
    const LINK_OVERLAYS = [
      { page: 1, url: "mailto:tyanklas@uwaterloo.ca", rect: [95, 723, 204, 739] },
      { page: 1, url: "https://tristan-yk.github.io/", rect: [211, 723, 300, 739] },
      { page: 1, url: "https://github.com/tristan-yk", rect: [307, 723, 410, 739] },
      { page: 1, url: "https://linkedin.com/in/tristanyanklassen", rect: [417, 723, 516, 739] },

      { page: 2, url: "mailto:tyanklas@uwaterloo.ca", rect: [67, 723, 193, 739] },
      { page: 2, url: "https://tristan-yk.github.io/", rect: [201, 723, 303, 739] },
      { page: 2, url: "https://github.com/tristan-yk", rect: [312, 723, 427, 739] },
      { page: 2, url: "https://linkedin.com/in/tristanyanklassen", rect: [437, 723, 546, 739] },

      { page: 3, url: "https://www.youtube.com/watch?v=hY5D-x-vRBs", rect: [297, 505, 434, 492] },
      { page: 3, url: "https://github.com/tristan-yk/dead-reckoning", rect: [222, 85, 265.8, 72] },

      { page: 4, url: "https://github.com/waterloo-rocketry/closedrocket", rect: [185.8, 339.5, 263, 324.9] },

      { page: 5, url: "https://github.com/tristan-yk/TeamAphelionCansat", rect: [186.5, 61.9, 256.1, 48] },

      { page: 6, url: "https://github.com/tristan-yk/Aroma", rect: [229.6, 524.4, 272.1, 513.3] },
    ];

    const container = document.getElementById("pdf-container");
    const fallback = document.getElementById("pdf-fallback");

    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.8.69/build/pdf.worker.mjs";

    function fail(err) {
      console.error(err);
      fallback.style.display = "block";
      container.innerHTML = "";
    }

    function getRenderWidth() {
      const pageEl = document.querySelector(".page");
      return Math.min(pageEl?.clientWidth ?? window.innerWidth, MAX_WIDTH);
    }

    function pdfRectToCss(viewport, rect) {
      const [x1, y1, x2, y2] = rect;
      const p1 = viewport.convertToViewportPoint(x1, y1);
      const p2 = viewport.convertToViewportPoint(x2, y2);

      const left = Math.min(p1[0], p2[0]);
      const top = Math.min(p1[1], p2[1]);
      const width = Math.abs(p2[0] - p1[0]);
      const height = Math.abs(p2[1] - p1[1]);

      return { left, top, width, height };
    }

    function addLinkOverlays(pageWrap, viewport, pageNum) {
      for (const o of LINK_OVERLAYS) {
        if (o.page !== pageNum) continue;

        const css = pdfRectToCss(viewport, o.rect);

        const a = document.createElement("a");
        a.href = o.url;
        a.target = "_blank";
        a.rel = "noopener";
        a.style.position = "absolute";
        a.style.zIndex = "10";
        a.style.left = `${css.left}px`;
        a.style.top = `${css.top}px`;
        a.style.width = `${css.width}px`;
        a.style.height = `${css.height}px`;

        // Keep clickable, but invisible
        a.style.background = "transparent";

        pageWrap.appendChild(a);
      }
    }

    let renderToken = 0;

    async function render() {
      const token = ++renderToken;

      try {
        const pdf = await pdfjsLib.getDocument(PDF_PATH).promise;

        // If a newer render started while we were loading, abandon this one.
        if (token !== renderToken) return;

        container.innerHTML = "";
        fallback.style.display = "none";

        const dpr = Math.min(window.devicePixelRatio || 1, DPR_CAP);
        const renderWidth = getRenderWidth();

        for (let n = 1; n <= pdf.numPages; n++) {
          // If a newer render started, stop work early.
          if (token !== renderToken) return;

          const page = await pdf.getPage(n);

          const unscaled = page.getViewport({ scale: 1 });

          // Integer CSS sizing to reduce seams
          const scale0 = renderWidth / unscaled.width;
          const cssW = Math.round(unscaled.width * scale0);
          const cssH = Math.round(unscaled.height * scale0);
          const scale = cssW / unscaled.width;

          const viewport = page.getViewport({ scale });
          const renderViewport = viewport.clone({ scale: viewport.scale * dpr });

          const pageWrap = document.createElement("div");
          pageWrap.className = "pdf-page";
          pageWrap.style.position = "relative";
          pageWrap.style.width = `${cssW}px`;
          pageWrap.style.height = `${cssH}px`;
          container.appendChild(pageWrap);

          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d", { alpha: false, desynchronized: true });

          canvas.width = Math.floor(renderViewport.width);
          canvas.height = Math.floor(renderViewport.height);
          canvas.style.width = `${cssW}px`;
          canvas.style.height = `${cssH}px`;
          canvas.style.position = "absolute";
          canvas.style.left = "0";
          canvas.style.top = "0";
          canvas.style.zIndex = "0";

          pageWrap.appendChild(canvas);

          await page.render({ canvasContext: ctx, viewport: renderViewport }).promise;

          // Add overlays based on CSS-sized viewport (not DPR-scaled viewport)
          addLinkOverlays(pageWrap, viewport, n);
        }
      } catch (err) {
        fail(err);
      }
    }

    // Initial render
    render();

    // Mobile fix:
    // On phones, fast scrolling can trigger "resize" when the browser UI shows/hides.
    // Only re-render when the *layout width* actually changes (rotation, split view, etc.).
    let lastW = window.innerWidth;
    let resizeTimer = null;

    window.addEventListener("resize", () => {
      const w = window.innerWidth;
      if (w === lastW) return; // ignore height-only resizes (scroll UI)
      lastW = w;

      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        render();
      }, 150);
    });

  </script>
</body>
</html>
